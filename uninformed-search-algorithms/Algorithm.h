#ifndef ALGORITHM_H
#define ALGORITHM_H

#include <stack>
#include <deque>
#include <functional>
#include <queue>
#include <set>
#include <cmath>

#include <QDebug>

#include <opencv2/imgproc.hpp>
#include <opencv2/imgcodecs.hpp>
#include <opencv2/highgui.hpp>

struct Node
{
    cv::Point _point;
    Node* _parent;
    size_t _level;
    double gCost; // Distance between the current point and its neighbour.
    double hCost; // Distance between the current point and the goal point.

    Node(const cv::Point& point, Node* parent, size_t level)
        : _point{point},
         _parent{parent},
         _level{level},
         gCost{0.0},
         hCost{0.0}
        {
        }

    Node(const Node &) = default;
    auto operator=(const Node &) -> Node & = default;
    ~Node() = default;
};

/// Helper struct to compare properly a set of points.
struct comparePoints {
    bool operator()(const cv::Point & a, const cv::Point & b) {
        if (a.x < b.x) return true;
        if (a.x > b.x) return false;
        if (a.y < b.y) return true;
        return false;
    }
};

/// Used to create a min heap.
struct CompareDistance {
    constexpr bool operator()(std::pair<Node*, double> const & a,
                              std::pair<Node*, double> const & b) const noexcept
    { return a.second > b.second; }
};

class Algorithm
{
public:
    Algorithm();

    /** @brief Receives two images, one to analize and other to draw.
     * @param img Normal Img to be draw.
     * @param bin_img Binary Image to be analized.
     */
    Algorithm(cv::Mat& img, cv::Mat& bin_img);

    /** @brief Algorithm to generate a path.
     * @param initial_state Initial state to start.
     * @param final_state The goal to reach.
     */
    void breadth_first_search(cv::Point& initial_state, const cv::Point& final_state);

    /** @brief Algorithm to generate a path.
     * @param initial_state Initial state to start.
     * @param final_state The goal to reach.
     */
    void depth_first_search(cv::Point& initial_state, const cv::Point& final_state);

    /** @brief Algorithm to generate the moves to follow to solve the game.
     * @param initial_state Initial state to start.
     * @param final_state The goal to reach.
     * @param max_depth The depth limit to search.
     */
    void iterative_deepening_search(cv::Point& initial_state, const cv::Point& final_state, size_t max_depth);

    /** @brief: Used with iterative deeping search to check each level based on a max depth,
     * will check or expand the corresponding states.
     * @param current_state State to be expanded or checked.
     * @param final_state The goal to reach.
     * @param visited All the states that are already visited, to improve performance.
     * @param max_depth The depth limit to search.
     * @return True if the final state is reached, otherwise false.
     */
    bool depth_limited_search(Node* current_state, const cv::Point& final_state, std::set< cv::Point, comparePoints >& visited, size_t max_depth);

    /** @brief Algorithm to find the shortest path using heuristic. (primero el mejor, Greedy Best-First Search).
      * @param current_state Initial state.
      * @param final_state The goal to reach.
      * */
    void best_first_search (cv::Point& initial_state, const cv::Point& final_state);

    /** @brief Algorithm to find the shortest path using heuristic and distance between two points.
      * @param current_state Initial state.
      * @param final_state The goal to reach.
      * */
    void a_star_search(cv::Point& initial_state, const cv::Point& final_state);

    /// Check if path exist.
    bool path_exist();

    /// Draw path on the pic.
    void draw_path();
    size_t get_nodes_expanded() const;
    size_t get_level() const;

    /** @brief Will search in all white pixels to get the nearest white pixel giben a ponit.
     *  @param point Point to be compared, needed to get the min distance between white pixels and the point.
     *  @return Nearest point to the user's point.
     * */
    cv::Point nearest_white_pixel(cv::Point& point);

    ~Algorithm();

private:
    Node *path;
    cv::Mat img, bin_img;
    size_t nodes_expanded = 0;      // Every time a node is expanded, this is increased.
    std::deque<Node *> all_nodes;   // Every node generated by the tree is saved here.


    /** @brief Check the point is in the image bounds.
     * @param point (x,y) point.
     * @return True is in the bounds, false otherwise.
     */
    bool out_bounds(const cv::Point& point);

    /** @brief Check the point if it's white or not.
     * @param point (x,y) point.
     * @return True is black, false otherwise.
    */
    bool is_white(const cv::Point& point);

    /** @brief Will apply eight-connectivity.
     * @param state Current state to move.
     * @return Adjacents from the state point.
    */
    std::deque<cv::Point> get_adjacents(cv::Point state);

    /** @brief: Will expand the current node, generating the next nodes.
     * @param current_state Current node that holds the current state.
     * @return A deque of the expanded nodes based on current state. */
    std::deque<Node *> expand_node(Node *current_state);
    double heuristic(cv::Point start, cv::Point end);
    double distance(cv::Point start, cv::Point end);
};

#endif // ALGORITHM_H
