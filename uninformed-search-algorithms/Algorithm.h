#ifndef ALGORITHM_H
#define ALGORITHM_H

#include <stack>
#include <deque>
#include <set>

#include <QDebug>

#include <opencv2/imgproc.hpp>
#include <opencv2/imgcodecs.hpp>
#include <opencv2/highgui.hpp>

/// Helper struct to compare properly a set of points.
struct comparePoints {
    bool operator()(const cv::Point & a, const cv::Point & b) {
        if (a.x < b.x) return true;
        if (a.x > b.x) return false;
        if (a.y < b.y) return true;
        return false;
    }
};

struct Node
{
    cv::Point _point;
    Node* _parent;
    size_t _level;

    Node(const cv::Point& point, Node* parent, size_t level)
        : _point{point},
         _parent{parent},
         _level{level}
        {
        }

    Node(const Node &) = default;
    auto operator=(const Node &) -> Node & = default;
    ~Node() = default;
};

class Algorithm
{
public:
    Algorithm();
    Algorithm(const cv::Mat& img, const cv::Mat& bin_img);

    void breadth_first_search(cv::Point& initial_state, const cv::Point& final_state);
    void depth_first_search(cv::Point& initial_state, const cv::Point& final_state);
    void iterative_deepening_search(cv::Point& initial_state, const cv::Point& final_state, size_t max_depth);
    bool depth_limited_search(Node* current_state, const cv::Point& final_state, std::set< cv::Point, comparePoints >& visited, size_t max_depth);

    bool path_exist();
    void draw_path();
    size_t get_nodes_expanded() const;
    size_t get_level() const;

    ~Algorithm();

private:
    Node *path;
    cv::Mat img, bin_img;
    size_t nodes_expanded = 0;      // Every time a node is expanded, this is increased.
    std::deque<Node *> all_nodes;   // Every node generated by the tree is saved here.
    std::set< cv::Point, comparePoints> global_visited;

    bool out_bounds(const cv::Point& point);
    bool is_white(const cv::Point& point);
    std::deque<cv::Point> get_adjacents(cv::Point state);
    std::deque<Node *> expand_node(Node *current_state);
};

#endif // ALGORITHM_H
